<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库练习]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Student(Sid,Sname,Sage,Ssex)学生表Sid：学号Sname：学生姓名Sage：学生年龄Ssex：学生性别Course(Cid,Cname,T#)课程表Cid：课程编号Cname：课程名称Tid：教师编号SC(Sid,Cid,score)成绩表Sid：学号Cid：课程编号score：成绩Teacher(Tid,Tname)教师表Tid：教师编号：Tname：教师名字 问题：1、查询“001”课程比“002”课程成绩高的所有学生的学号1234select a.sid from (select sid,score from sc where cid=&apos;001&apos;)a,(select sid,score from sc where cid=&apos;002&apos;)b where a.sid = b.sid and a.score&gt;b.score; 2、查询平均成绩大于60分的同学的学号和平均成绩123select sid,avg(score) from scgroup by sid having avg(score)&gt;60; 3、查询所有同学的学号、姓名、选课数、总成绩1234567select s.sid,s.sname,count_cid as 选课数, sum_score as 总成绩from student sleft join (select sid,count(cid) as count_cid,sum(score) as sum_score from sc group by sid )scon s.sid = sc.sid; 4、查询姓‘李’的老师的个数：123select count(tname)from teacher where tname like &apos;李%&apos;; 5、查询没有学过“叶平”老师可的同学的学号、姓名：1234567891011select s.sid,s.sname from student as s where s.sid not in ( select DISTINCT sid from sc as sc where sc.cid in ( select cid from course as c left join teacher as t on c.tid = t.tid where t.tname = &apos;叶平&apos;)); 6、查询学过“叶平”老师所教的所有课的同学的学号、姓名：12345678910111213141516select s.sid,s.sname from student as s where s.sid in ( select distinct sc.sid from sc as sc where sc.cid in ( select cid from course as c left join teacher as t on c.tid = t.tid where t.tname = &apos;叶平&apos;) group by sc.sid HAVING count(cid)= (select count(cid) from course as c left join teacher as t on c.tid = t.tid where t.tname = &apos;叶平&apos;)); 7、查询学过“011”并且也学过编号“002”课程的同学的学号、姓名：123456789101112131415161718SELECT s.sid,s.sname from student as s left join sc as sc on s.sid = sc.sidwhere sc.cid = &apos;001&apos;and EXISTS( select * from sc as sc_2 where sc.sid = sc_2.sid and sc_2.cid=&apos;002&apos;);select s.sid,s.snamefrom student as s left join sc as sc on sc.sid = s.sidwhere sc.cid = &apos;001&apos;and s.sid in ( select sid from sc as sc_2 where sc_2.cid=&apos;002&apos; and sc_2.sid = sc.sid); 8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名：12345678select sid,snamefrom (select student.sid,student.sname,score, (select score from sc as sc_2 where sc_2.sid = student.sid and sc_2.cid = &apos;002&apos;) as score2 from student,sc where student.sid=sc.sid and cid = &apos;001&apos;) s_2where score2&lt;score; 9、查询所有课程成绩小于60的同学的学号、姓名：123456789101112select sid,snamefrom studentwhere sid not in (select s.sid from student s,sc where s.sid=sc.sid and score&gt;60 );select sid,snamefrom student swhere not EXISTS (select s.sid from sc where sc.sid = s.sid and sc.score&gt;60); 10、查询没有学全所有课的同学的学号、姓名：1234567891011121314select s.sid,s.snamefrom student s ,sc sc where s.sid = sc.sidgroup by s.sid,s.snamehaving count(sc.cid)&lt;(select count(cid) from course);select s.sid,s.snamefrom student s right join sc sc on s.sid = sc.sidgroup by s.sid,s.snamehaving count(sc.cid)&lt;(select count(cid) from course); 11、查询至少有一门课与学号为“1001”同学所学相同的同学的学号和姓名：123456789101112131415161718select student.sid,snamefrom student,sc where student.sid = sc.sidand cid in (select cid from sc where sid=&apos;1001&apos;);select s.sid,s.snamefrom sc sc left join student as son sc.sid = s.sidwhere sc.cid in (select cid from sc where sid=&apos;1001&apos;);select sc_1.sid,s.snamefrom sc sc_1 left join student as son sc_1.sid = s.sidwhere exists (select sc_2.cid from sc as sc_2 where sc_1.cid = sc_2.cid and sc_2.sid = &apos;1001&apos;); 12、查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名；13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩：1234567update sc set score = (select avg(sc_2.score) from sc sc_2 where sc_2.cid = sc.cid)where cid in (select c.cid from course c left join teacher t on t.tid = c.tid where t.tname = &apos;叶平&apos;); 14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名：12345678910111213141516select sc_1.sid from (select cid from sc where sid=&apos;1002&apos;)aleft join sc sc_1 on a.cid = sc_1.cidwhere sc_1.sid&lt;&gt;&apos;1002&apos; group by sc_1.sid having count(sc_1.cid) = (select count(cid) from sc where sid=&apos;1002&apos;);select a.sid,s.sname from (select sid,GROUP_CONCAT(cid order by cid separator &apos;,&apos;) as cid_str from sc where sid=&apos;1002&apos;)b,(select sid,GROUP_CONCAT(cid order by cid separator &apos;,&apos;) as cid_str from sc group by sid)aleft join student s on a.sid = s.sidwhere a.cid_str = b.cid_str and a.sid&lt;&gt;&apos;1002&apos;; 15、删除学习“叶平”老师课的SC表记录：12345delete from sc WHEREcid in (select c.cid from course c LEFT JOIN teacher t on c.tid=t.tid where t.tname = &apos;叶平&apos;); 16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、002号课的平均成绩：1234insert into sc select sid,&apos;002&apos;,(select avg(score) from sc where cid=&apos;0022&apos;)from student where sid not in (select sid from sc where cid=&apos;002&apos;); 17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示：学生ID，数据库，企业管理，英语，有效课程数，有效平均分：1234567891011select sid as 学生id,(SELECT score from sc where sc.sid = t.sid and cid=&apos;004&apos;) as 数据库,(select score from sc where sc.sid = t.sid and cid=&apos;001&apos;) as 企业管理,(select score from sc where sc.sid = t.sid and cid=&apos;015&apos;) as 英语,count(cid) as 有效课程数, avg(t.score) as 平均成绩from sc as t group by sidorder by avg(t.score); 18、查询各科成绩最高和最低的分：以如下的形式显示：课程ID，最高分，最低分123456789101112131415select l.cid as 课程id,l.score as 最高分,r.score as 最低分from sc l,sc rwhere l.cid = r.cidand l.score = (select max(t.score) from sc t where l.cid = t.cid group by t.cid)and r.score = (select min(t.score) from sc t where r.cid = t.cid group by t.cid)order by l.cid;select cid as 课程id,max(score) as 最高分,min(score) as 最低分from sc group by cid; 19、按各科平均成绩从低到高和及格率的百分数从高到低顺序：12345678910111213SELECT t.cid as 课程号,c.cname as 课程名,COALESCE(avg(score),0) as 平均成绩,100*sum(case when COALESCE(score,0)&gt;=60 then 1 else 0 END)/count(*) as 及格百分数from sc tleft join course c on t.cid = c.cidgroup by t.cidorder by 100*sum(case when COALESCE(score,0)&gt;=60 then 1 else 0 END)/count(*); 20、查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）：21、查询不同老师所教不同课程平均分从高到低显示：123456789select t.tid as 教师id,t.tname as 教师姓名,sc.cid as 课程id,avg(score) as 平均成绩from sc as scLEFT JOIN course c on sc.cid = c.cidleft join teacher t on c.tid = t.tidgroup by sc.cid order by avg(sc.score) desc; 22、查询如下课程成绩第3名到第6名的学生成绩单：企业管理(001)，马克思(002)，UML(003)，数据库(004)：23、统计下列各科成绩，各分数段人数：课程ID，课程名称，[100-85],[85-70],[70-60],[ 小于60] ：123456789select sc.cid as 课程id,cname as 课程名称,sum(case when score between 85 and 100 then 1 else 0 end) as &apos;[100-85]&apos;,sum(case when score between 70 and 85 then 1 else 0 end) as &apos;[85-70]&apos;,sum(case when score between 60 and 70 then 1 else 0 end) as &apos;[70-60]&apos;,sum(case when score&lt;60 then 1 else 0 end) as &apos;[60-0]&apos;from sc as sc left join course as con sc.cid = c.cidgroup by sc.cid; 24、查询学生平均成绩及其名次：1234567select 1+(select count(distinct 平均成绩) from (select sid,avg(score) as 平均成绩 from sc group by sid)t1 where 平均成绩&gt;t2.平均成绩) as 名次,sid as 学生学号,平均成绩 from (select sid,avg(score) 平均成绩 from sc group by sid) as t2order by 平均成绩 desc; 25、查询各科成绩前三名的记录（不考虑成绩并列情况）：12345678select sid,cid,scorefrom sc sc_1where (select count(3) from sc sc_2 where sc_1.cid = sc_2.cid and sc_2.score&gt;=sc_1.score)&lt;=2 order by sc_1.cid); 26、查询每门课程被选修的学生数：123select cid, count(sid)from sc group by cid; 27、查询出只选修一门课程的全部学生的学号和姓名：1234567select sc.sid,s.sname,count(sc.cid) as 课程数from sc as scLEFT JOIN student as son sc.sid = s.sidgroup by sc.sidhaving count(sc.cid)=1; 28、查询男生、女生人数：123456select count(ssex) as 男生人数from studentgroup by ssexhaving ssex = &apos;男&apos;;select count(2) from studentwhere ssex = &apos;女&apos;; 29、查询姓“张”的学生名单：123select sid,snamefrom student where sname like &apos;张%&apos;; 30、查询同名同姓的学生名单，并统计同名人数：1234select sname,count(8)from student group by snamehaving count(8)&gt;1; 31、1981年出生的学生名单（注：student表中sage列的类型是datetime）:32、查询平均成绩大于85的所有学生的学号、姓名和平均成绩：123456select s.sname,sc.sid,avg(sc.score) as 平均成绩from sc as scleft join student as s on sc.sid = s.sidgroup by sc.sid having avg(sc.score)&gt;85; 33、查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列：1234select cid,avg(score)from sc group by cidorder by avg(score),cid desc; 34、查询课程名称为“数据库”，且分数低于60的学生名字和分数：12345select c.cname,s.sid,s.sname,sc.scorefrom course cleft join sc on sc.cid = c.cidLEFT JOIN student s on s.sid = sc.sidwhere c.cname = &apos;数据库&apos; and sc.score&lt;60; 35、查询所有学生的选课情况：1234select sc.sid,sc.cid,s.sname,c.cnamefrom sc LEFT JOIN course c on sc.cid = c.cidleft join student s on sc.sid = s.sid; 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数：12345select distinct s.sid,s.sname,sc.cid,sc.scorefrom sc left join student s on sc.sid = s.sidleft join course c on sc.cid = c.cidwhere sc.score&gt;70; 37、查询不及格的课程，并按课程号从大到小的排列：1234select cidfrom sc where score&lt;60ORDER BY cid; 38、查询课程编号为“003”且课程成绩在80分以上的学生的学号和姓名：1234select sc.sid,s.sname from sc left join student s on sc.sid = s.sidwhere sc.cid = &apos;003&apos; and sc.score&gt;80; 39、求选了课程的学生人数：12select count(2) from (select distinct sid from sc)a; 40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩：12345678910select s.sname,sc.scorefrom sc sc left join student s on sc.sid = s.sidleft join course c on sc.cid = c.cidleft join teacher t on c.tid = t.tidwhere t.tname = &apos;叶平&apos;and sc.score = (select max(score) from sc sc_1 where sc.cid = sc_1.cid); 41、查询各个课程及相应的选修人数：1select cid,count(*) from sc group by cid; 42、查询不同课程成绩相同的学生和学号、课程号、学生成绩：1234select DISTINCT a.sid,a.cid,a.scorefrom sc as a ,sc as b where a.score = b.scoreand a.cid &lt;&gt; b.cid; 43、查询每门课程成绩最好的前两名：44、统计每门课程的学生选修人数(超过10人的课程才统计)。要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序：12345select cid as 课程号,count(8) as 选修人数from scgroup by cidHAVING count(sid)&gt;10order by count(8) desc,cid; 45、检索至少选修两门课程的学生学号：1234select sidfrom scgroup by sidhaving count(8)&gt;=2; 46、查询全部学生选修的课程和课程号和课程名：123select cid,cnamefrom course where cid in (select cid from sc group by cid); 47、查询没学过”叶平”老师讲授的任一门课程的学生姓名：12345678select sname from student where sid not in ( select sid from sc,course,teacher where course.tid = teacher.tid and sc.cid = course.cid and teacher.tname=&apos;叶平&apos;); 48、查询两门以上不及格课程的同学的学号以及其平均成绩：12345678910select sid,avg(COALESCE(score,0))from scwhere sid in ( select sid from sc where score&lt;60 group by sid having count(8)&gt;2)group by sid; 49、检索“004”课程分数小于60，按分数降序排列的同学学号：12345select sid,scorefrom scwhere cid=&apos;004&apos;and score&lt;60order by score desc; 50、删除“002”同学的“001”课程的成绩：123delete from scwhere sid = &apos;002&apos;and cid = &apos;001&apos;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC工作原理]]></title>
    <url>%2F2019%2F03%2F04%2FSpringMVC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络经典面试题—从输入URL到页面加载发生了什么]]></title>
    <url>%2F2019%2F03%2F04%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[1、DNS域名解析2、TCP连接3、HTTP请求4、服务器处理请求返回报文5、浏览器渲染页面 DNS域名解析域名(url)解析成IP地址的过程 递归查询方法 根域名服务器——&gt;顶级域名服务器——&gt;网站服务器——&gt;IP地址例：www.chi365.cn . ——&gt; .cn ——&gt;chi365.cn——&gt;IP地址 TCP连接三次握手 建立tcp连接 四次挥手 断开连接 HTTP请求建立稳定传输连接以后就可以构建并发送HTTP请求报文。 HTTP请求报文格式：请求行+请求头+空行+消息体，请求行包括请求方式（GET/POST/DELETE/PUT）、请求资源路径（URL）、HTTP版本号； HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。 状态码：1** 这一类型的状态码，代表请求已被接受，需要继续处理。2** 成功，这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。3** 这类状态码代表需要客户端采取进一步的操作才能完成请求。重定向4** 请求错误，这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。5** 服务器错误，这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。 获得HTTP请求报文，解析封装成HTTP request对象（这部分一般由Web服务器完成，如tomcat）。 浏览器渲染页面]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记，计算机网络，面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序12345678910111213141516/* 外层循环n-1，内层循环n-1-i，比较j和j+1。*/public int[] mpSort(int[] a)&#123; int n = a.length; for(int i=0;i&lt;n-1;i++)&#123; for(int j=0;j&lt;n-1-i;j++)&#123; if(a[j]&gt;a[j+1])&#123; int temp = a[j+1]; a[j+1] = a[j]; a[j] = temp; &#125; &#125; &#125; return a;&#125; 选择排序123456789101112131415public int[] selectSort(int[] a)&#123; int n = a.length; for(int i=0;i&lt;n;i++)&#123; int max = 0; for(int j=0;j&lt;n-i;j++)&#123; if(a[j]&gt;a[max])&#123; max = j; &#125; &#125; int temp = a[n-1-i]; a[n-1-i] = a[max]; a[max] = temp; &#125; return a;&#125; 插入排序123456789101112131415public int[] insertSort(int[] a)&#123; int i,j,temp; for(i=1;i&lt;a.length;i++)&#123; temp = a[i]; for(j = i-1;j&gt;=0;j--)&#123; if(temp&gt;=a[j])&#123; break;//找到插入位置退出循环 &#125;else&#123; a[j+1] = a[j];//未到插入位置往后移 &#125; &#125; a[j+1] = temp;//插入位置赋值 &#125; return a;&#125; 快速排序12345678910111213141516171819202122232425262728293031public void quickSort(int[] a,int low,int high)&#123; if(low&gt;high)&#123; return; &#125; int start = low;//左部循环指针，初始指向最左端 int end = high;//右部循环指针，初始指向最右端 int key = a[low];//选一个key while (start&lt;end)&#123; //右部循环，如果end元素大于key，指针向左移，如果end元素小于key，退出循环 while (start&lt;end &amp;&amp; a[end]&gt;key)&#123; end--; &#125; //左部循环，如果start元素小于key，指针向右移，如果start元素大于key，退出循环 while(start&lt;end &amp;&amp; a[start]&lt;=key)&#123; start++; &#125; //交换两指针对应元素，继续循环，直到两指针指向同一元素。目的是将所以大于key的元素移向右端，所有小于key的元素移向左端。 if(start&lt;end)&#123; int temp = a[start]; a[start] = a[end]; a[end] = temp; &#125; &#125; //将key元素与指针所指元素互换，形成key左部全部小于key，右部全部大于key a[low] = a[start]; a[start] = key; //分别递归调用两端元素 quickSort(a,low,start-1); quickSort(a,start+1,high);&#125; 【一个非常全面的排序算法详解】——&gt;在这里]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记，算法，排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——传输层协议]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94TCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[网络七层协议 TCP协议和UDP协议TCP协议特点1、面向连接的运输层协议。2、每条TCP连接只能有两个端点，是点对点的连接。3、TCP服务提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达。4、面向字节流。 UDP协议特点1、UDP是无连接的传输层协议。2、不可靠。3、面向报文的。对应用层交下来的报文，不合并、不拆分，保留报文边界。4、UDP没有拥塞处理。5、UDP支持一对一、一对多、多对多。 TCP协议和UDP协议区别1、TCP是可靠传输,UDP是不可靠传输; 2、TCP面向连接,UDP无连接; 3、TCP传输数据有序,UDP不保证数据的有序性; 4、TCP不保存数据边界,UDP保留数据边界; 5、TCP传输速度相对UDP较慢; 6、TCP有流量控制和拥塞控制,UDP没有; 7、TCP是重量级协议,UDP是轻量级协议; 8、TCP首部较长２０字节,UDP首部较短８字节; 基于TCP和UDP的常用协议HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议 TCP协议三次握手和四次挥手第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 常见面试题【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 【问题3】为什么不能用两次握手进行连接？ 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75s发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记，计算机网络，TCP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（三）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略垃圾回收算法标记清除算法首先标记要回收的对象，标记完成后统一回收被标记的对象。缺点：1.效率低。2.会产生大量不连续的内存碎片。 复制算法它将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 缺点很明显，内存空间比原来少了一半。 JAVA虚拟机就是用这张算法回收新生代。将内存分为Eden和两个Survivor区，每次使用Eden和一个Survivor区，当回收时，将Eden和Survivor区还存活的对象一次性全复制到另一个Survivor区，最后清除Eden和这个Survivor区的内存。HotSpot虚拟机默认Eden和Survivor大小比例是8:1，所以每次使用90%内存。当Survivor区不够用时，需要依赖其他内存（老年代）进行分配担保。 标记-整理算法老年代一般不能直接选用复制算法，因为有大量存活对象需要复制。根据老年代的特点，有人提出标记整理算法，标记过程和标记清除算法一样，但后面是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代回收算法Java虚拟机将堆内存分为新生代和老生代，新生代使用复制算法；老生代使用标记清除或者标记整理算法。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（二）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略判断对象需要回收的算法引用计数法给对象添加一个引用技术器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象都是不能被再次使用的。 Java虚拟机没有选用引用计数算法来管理内存的，原因是它很难解决相互循环引用的问题。 1234例如：objA.instance = objB;objB.instance = objA;由于这两个对象相互引用着所以计数器永远不为0. 可达性分析算法主流语言多是用可达性分析算法判断对象是否存活的。这个算法的基本思路是：通过一系列的GC Roots的对象为起始点，从这些节点开始向下搜索，搜索走过的路径为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 JDK关于“引用”的定义JDK1.2以后，Java对引用的概念进行补充，引用分为： 强引用（Strong Reference）：垃圾回收器永远不会回收。 软引用（Soft Reference）：描述一些还有用但是并非必需的对象。 弱引用（Weak Reference）：也是描述非必需对象。比软引用更弱。 虚引用（Phantom Reference）：最弱。 即使在可达性分析算法不可达的对象，也并不是立刻就回收。 可达性算法不可达–&gt;后存放在F-Queue队列–&gt;finalize()方法 执行finalize()方法的对象依然有可能存活。 回收方法区方法区也叫“永久代”，永久代的回收主要回收两部分：废弃常量和无用的类。 无用的类：该类所有实例已经被回收；加载该类的ClassLoader已经被回收；无法在任何地方通过反射访问该类的方法。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（一）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第二章 JVM内存管理机制程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每条线程都有一个独立的程序计数器，所以程序计数器是线程私有的内存。此内存区是唯一一个在java虚拟机中没有规定任何OutOfMemoryError情况的区域。 JAVA虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法接口等信息。虚拟机栈也是线程私有的。Java虚拟机栈可以动态拓展，也可以固定长度，如果无法申请到足够的内存，就会抛出OutOfMemoryError。如果线程请求的线程深度大于虚拟机所允许的深度则会抛出StackOverflowError（递归调用易出现）。 局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，指向对象的指针）和returnAddress类型（指向一条字节码指令的地址）。局部变量空间单位（Slot），64位长的long和double占用两个Slot，其余占用1个Slot。 本地方法栈服务于Native方法。与虚拟机栈相似。 Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是线程共享的。在虚拟机启动时创建。存放对象实例，几乎所有对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，所以也叫GC堆。垃圾回收机制大多采用分代收集算法，所以Java堆还可以细分为新生代、老生代，再细致分为Eden区、From Survivor区、To Survivor区等。Java堆也是可扩展的，无法扩展时抛出OutOfMemoryError。 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是线程共享的内存区域。 运行时常量池是方法区的一部分，用于存放编译期生成的变量（类加载后进入方法区的变量）]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客编写]]></title>
    <url>%2F2019%2F02%2F28%2F111%2F</url>
    <content type="text"><![CDATA[评论插件：valine（数据库LeanCloud，账号163邮箱） 分类添加：在文章头部指定一个categories属性。 标签添加：在文章头部指定一个tags属性。 Markdown语法参考 代码示例：123public class hello&#123; &#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
