<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（三）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略垃圾回收算法标记清除算法首先标记要回收的对象，标记完成后统一回收被标记的对象。缺点：1.效率低。2.会产生大量不连续的内存碎片。 复制算法它将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 缺点很明显，内存空间比原来少了一半。 JAVA虚拟机就是用这张算法回收新生代。将内存分为Eden和两个Survivor区，每次使用Eden和一个Survivor区，当回收时，将Eden和Survivor区还存活的对象一次性全复制到另一个Survivor区，最后清除Eden和这个Survivor区的内存。HotSpot虚拟机默认Eden和Survivor大小比例是8:1，所以每次使用90%内存。当Survivor区不够用时，需要依赖其他内存（老年代）进行分配担保。 标记-整理算法老年代一般不能直接选用复制算法，因为有大量存活对象需要复制。根据老年代的特点，有人提出标记整理算法，标记过程和标记清除算法一样，但后面是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代回收算法Java虚拟机将堆内存分为新生代和老生代，新生代使用复制算法；老生代使用标记清除或者标记整理算法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（二）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略判断对象需要回收的算法引用计数法给对象添加一个引用技术器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象都是不能被再次使用的。 Java虚拟机没有选用引用计数算法来管理内存的，原因是它很难解决相互循环引用的问题。 1234例如：objA.instance = objB;objB.instance = objA;由于这两个对象相互引用着所以计数器永远不为0. 可达性分析算法主流语言多是用可达性分析算法判断对象是否存活的。这个算法的基本思路是：通过一系列的GC Roots的对象为起始点，从这些节点开始向下搜索，搜索走过的路径为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 JDK关于“引用”的定义JDK1.2以后，Java对引用的概念进行补充，引用分为： 强引用（Strong Reference）：垃圾回收器永远不会回收。 软引用（Soft Reference）：描述一些还有用但是并非必需的对象。 弱引用（Weak Reference）：也是描述非必需对象。比软引用更弱。 虚引用（Phantom Reference）：最弱。 即使在可达性分析算法不可达的对象，也并不是立刻就回收。 可达性算法不可达–&gt;后存放在F-Queue队列–&gt;finalize()方法 执行finalize()方法的对象依然有可能存活。 回收方法区方法区也叫“永久代”，永久代的回收主要回收两部分：废弃常量和无用的类。 无用的类：该类所有实例已经被回收；加载该类的ClassLoader已经被回收；无法在任何地方通过反射访问该类的方法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（一）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第二章 JVM内存管理机制程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每条线程都有一个独立的程序计数器，所以程序计数器是线程私有的内存。此内存区是唯一一个在java虚拟机中没有规定任何OutOfMemoryError情况的区域。 JAVA虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法接口等信息。虚拟机栈也是线程私有的。Java虚拟机栈可以动态拓展，也可以固定长度，如果无法申请到足够的内存，就会抛出OutOfMemoryError。如果线程请求的线程深度大于虚拟机所允许的深度则会抛出StackOverflowError（递归调用易出现）。 局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，指向对象的指针）和returnAddress类型（指向一条字节码指令的地址）。局部变量空间单位（Slot），64位长的long和double占用两个Slot，其余占用1个Slot。 本地方法栈服务于Native方法。与虚拟机栈相似。 Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是线程共享的。在虚拟机启动时创建。存放对象实例，几乎所有对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，所以也叫GC堆。垃圾回收机制大多采用分代收集算法，所以Java堆还可以细分为新生代、老生代，再细致分为Eden区、From Survivor区、To Survivor区等。Java堆也是可扩展的，无法扩展时抛出OutOfMemoryError。 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是线程共享的内存区域。 运行时常量池是方法区的一部分，用于存放编译期生成的变量（类加载后进入方法区的变量）]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客编写]]></title>
    <url>%2F2019%2F02%2F28%2F111%2F</url>
    <content type="text"><![CDATA[评论插件：valine（数据库LeanCloud，账号163邮箱） 分类添加：在文章头部指定一个categories属性。 标签添加：在文章头部指定一个tags属性。 Markdown语法参考 代码示例：123public class hello&#123; &#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
