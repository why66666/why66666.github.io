<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[编程题——排队购票问题]]></title>
    <url>%2F2019%2F03%2F14%2F%E7%BC%96%E7%A8%8B%E9%A2%98%E2%80%94%E2%80%94%E6%8E%92%E9%98%9F%E8%B4%AD%E7%A5%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[售票工作正在进行，每张票为50元，现在有m+n人排队等待购票，其中有m人手持50元，n人手持100元，假设售票处不设找零，那么若想使售票处不会出现找不开零钱的局面，请你帮忙设计不同的排队方案。特别说明的是，拿同样面值的人对换位置为同一种方案。 算法分析：一：n=0; 那么说明买票的人都是手持50元，所以不会出现找不开零钱的局面，所以这是一种排队方案；二：m=0; 那么说明买票的人都是手持100元，所以一定会找不开零钱，所以没有排队方案；三：m&lt;n; 那么说明买票的人中，手持50元的人数少于手持100元的人数，所以肯定会出现找不开零钱的局面，所以同样没有排队方案；四：m&gt;n; 此时，买票的人中，手持50元的人数多于手持100元的人数，所以可以有排队方案，我们这里来分析一下第m+n人的位置：（1）：第（m+n）人手持100元站在第（m+n-1）人的后面，那么他之前的人有(m)人手持50元，有(n-1)人手持100元，此种情况共有f(m,n-1)种排队方式；（2）：第（m+n）人手持50元站在第（m+n-1）人的后面，那么他之前的人有(m-1)人手持50元，有(n)人手持100元，此种情况共有f(m-1,n)种排队方式；所以通过第（m+n）人就可以分析出递归关系为：f(m,n)=f(m-1,n)+f(m,n-1)刚刚分析的边界条件： 当m&lt;n时，f(m,n)=0; 当n=0时，f(m,n)=1; 当 m=0时，f(m,n)=0; 123456789101112131415161718192021222324/**** */public class maipiao &#123; static long f(int m,int n)&#123; long y; if(n==0) y = 1; else if(m&lt;n) y = 0; else y = f(m-1,n)+f(m,n-1); return y; &#125; public static void main(String[] args) &#123; int m,n; Scanner in=new Scanner(System.in); System.out.println(&quot;input m--&gt;&quot;); m=in.nextInt(); System.out.println(&quot;input n--&gt;&quot;); n=in.nextInt(); System.out.println(&quot;wait&quot;); System.out.println(f(m,n)); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树遍历]]></title>
    <url>%2F2019%2F03%2F13%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627public void preOrder(BinaryTreeNode binaryTree)&#123; if(binaryTree!=null)&#123; System.out.println(binaryTree.getValue()); if(binaryTree.getLeft()!=null)&#123; preOrder(binaryTree.getLeft()); &#125; if(binaryTree.getRight()!=null)&#123; preOrder(binaryTree.getRight()); &#125; &#125; &#125; public void preOrderStack(BinaryTreeNode binaryTreeNode)&#123; Stack&lt;BinaryTreeNode&gt; binaryTreeNodeStack = new Stack&lt;BinaryTreeNode&gt;(); while(true)&#123; if(binaryTreeNode!=null)&#123; System.out.println(binaryTreeNode.getValue()); binaryTreeNodeStack.push(binaryTreeNode); binaryTreeNode = binaryTreeNode.getLeft(); &#125;else&#123; if(binaryTreeNodeStack.isEmpty())&#123; break; &#125; binaryTreeNode = binaryTreeNodeStack.pop(); binaryTreeNode = binaryTreeNode.getRight(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jackson]]></title>
    <url>%2F2019%2F03%2F13%2FJackson%2F</url>
    <content type="text"><![CDATA[Jackson 简介Jackson 是一个简单基于 Java 应用库，Jackson 可以轻松的将 Java 对象转换成 json 对象和 xml 文档，同样也可以将 json、xml 转换成 Java 对象。Jackson 所依赖的 jar 包较少，简单易用并且性能也要相对高些，并且 Jackson 社区相对比较活跃，更新速度也比较快。 Jackson 特点·容易使用 - jackson API 提供了一个高层次外观，以简化常用的用例。·无需创建映射 - API提供了默认的映射大部分对象序列化。·性能高 - 快速，低内存占用，适合大型对象图表或系统。·干净的 JSON - jackson 创建一个干净和紧凑的 JSON 结果，这是让人很容易阅读。·不依赖 - 库不需要任何其他的库，除了 JDK。·开源代码 - jackson 是开源的，可以免费使用。 Jackson 注解Jackson 类库包含了很多注解，可以让我们快速建立 Java 类与 JSON 之间的关系。 @JsonProperty@JsonProperty 注解指定一个属性用于 JSON 映射，默认情况下映射的 JSON 属性与注解的属性名称相同，不过可以使用该注解的 value 值修改 JSON 属性名，该注解还有一个 index 属性指定生成 JSON 属性的顺序，如果有必要的话。 @JsonIgnore@JsonIgnore 注解用于排除某个属性，这样该属性就不会被 Jackson 序列化和反序列化。 @JsonIgnoreProperties@JsonIgnoreProperties 注解是类注解。在序列化为 JSON 的时候，@JsonIgnoreProperties({“prop1”, “prop2”}) 会忽略 pro1 和 pro2 两个属性。在从 JSON 反序列化为 Java 类的时候，@JsonIgnoreProperties(ignoreUnknown=true) 会忽略所有没有 Getter 和 Setter 的属性。该注解在 Java 类和 JSON 不完全匹配的时候很有用。 @JsonIgnoreType@JsonIgnoreType 也是类注解，会排除所有指定类型的属性。 @JsonPropertyOrder@JsonPropertyOrder 和 @JsonProperty 的 index 属性类似，指定属性序列化时的顺序。 @JsonRootName@JsonRootName 注解用于指定 JSON 根属性的名称。 Jackson 使用实例对象的序列化与反序列化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.funtl.hello.httpclient;import com.fasterxml.jackson.core.JsonParseException;import com.fasterxml.jackson.databind.JsonMappingException;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;public class JsonTester &#123; public static void main(String[] args) &#123; // 创建 ObjectMapper 对象 ObjectMapper mapper = new ObjectMapper(); String jsonString = &quot;&#123;\&quot;name\&quot;:\&quot;Mahesh\&quot;, \&quot;age\&quot;:21&#125;&quot;; try &#123; // 反序列化 JSON 到对象 Student student = mapper.readValue(jsonString, Student.class); System.out.println(student); // 序列化对象到 JSON String json = mapper.writeValueAsString(student); System.out.println(json); &#125; catch (JsonParseException e) &#123; e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Student &#123; private String name; private int age; public Student() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String toString() &#123; return &quot;Student [ name: &quot; + name + &quot;, age: &quot; + age + &quot; ]&quot;; &#125;&#125; 集合的序列化与反序列化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.funtl.hello.httpclient;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;import java.util.ArrayList;import java.util.List;public class JsonTester &#123; public static void main(String[] args) &#123; // 创建 ObjectMapper 对象 ObjectMapper mapper = new ObjectMapper(); String jsonString = &quot;&#123;\&quot;draw\&quot;:1,\&quot;recordsTotal\&quot;:1,\&quot;recordsFiltered\&quot;:1,\&quot;data\&quot;:[&#123;\&quot;id\&quot;:33,\&quot;title\&quot;:\&quot;ad1\&quot;,\&quot;subTitle\&quot;:\&quot;ad1\&quot;,\&quot;titleDesc\&quot;:\&quot;ad1\&quot;,\&quot;url\&quot;:\&quot;https://sale.jd.com/act/XkCzhoisOMSW.html\&quot;,\&quot;pic\&quot;:\&quot;https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg\&quot;,\&quot;pic2\&quot;:\&quot;\&quot;,\&quot;content\&quot;:\&quot;&lt;p&gt;&lt;br&gt;&lt;/p&gt;\&quot;&#125;],\&quot;error\&quot;:null&#125;&quot;; try &#123; // 反序列化 JSON 到树 JsonNode jsonNode = mapper.readTree(jsonString); // 从树中读取 data 节点 JsonNode jsonData = jsonNode.findPath(&quot;data&quot;); System.out.println(jsonData); // 反序列化 JSON 到集合 JavaType javaType = mapper.getTypeFactory().constructParametricType(ArrayList.class, TbContent.class); List&lt;TbContent&gt; tbContents = mapper.readValue(jsonData.toString(), javaType); for (TbContent tbContent : tbContents) &#123; System.out.println(tbContent); &#125; // 序列化集合到 JSON String json = mapper.writeValueAsString(tbContents); System.out.println(json); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class TbContent &#123; private Long id; private String title; private String subTitle; private String titleDesc; private String url; private String pic; private String pic2; private String content; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getSubTitle() &#123; return subTitle; &#125; public void setSubTitle(String subTitle) &#123; this.subTitle = subTitle; &#125; public String getTitleDesc() &#123; return titleDesc; &#125; public void setTitleDesc(String titleDesc) &#123; this.titleDesc = titleDesc; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getPic() &#123; return pic; &#125; public void setPic(String pic) &#123; this.pic = pic; &#125; public String getPic2() &#123; return pic2; &#125; public void setPic2(String pic2) &#123; this.pic2 = pic2; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; @Override public String toString() &#123; return &quot;TbContent&#123;&quot; + &quot;id=&quot; + id + &quot;, title=&apos;&quot; + title + &apos;\&apos;&apos; + &quot;, subTitle=&apos;&quot; + subTitle + &apos;\&apos;&apos; + &quot;, titleDesc=&apos;&quot; + titleDesc + &apos;\&apos;&apos; + &quot;, url=&apos;&quot; + url + &apos;\&apos;&apos; + &quot;, pic=&apos;&quot; + pic + &apos;\&apos;&apos; + &quot;, pic2=&apos;&quot; + pic2 + &apos;\&apos;&apos; + &quot;, content=&apos;&quot; + content + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Jackson</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appache HttpClient]]></title>
    <url>%2F2019%2F03%2F13%2FAppache-HttpClient%2F</url>
    <content type="text"><![CDATA[单体开发简单架构图 HttpClientHttpClient 相比传统 JDK 自带的 URLConnection，增加了易用性和灵活性，它不仅是客户端发送 HTTP 请求变得容易，而且也方便了开发人员测试接口（基于 HTTP 协议的），即提高了开发的效率，也方便提高代码的健壮性。因此熟练掌握 HttpClient 是很重要的必修内容，掌握 HttpClient 后，相信对于 HTTP 协议的了解会更加深入。 Apache HttpClient 特性·基于标准、纯净的 Java 语言。实现了 HTTP 1.0 和 HTTP 1.1·以可扩展的面向对象的结构实现了 HTTP 全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。·支持 HTTPS 协议。·通过 HTTP 代理建立透明的连接。·利用 CONNECT 方法通过 HTTP 代理建立隧道的 HTTPS 连接。·Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos 认证方案。·插件式的自定义认证方案。·便携可靠的套接字工厂使它更容易的使用第三方解决方案。·连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。·自动处理 Set-Cookie 中的 Cookie。·插件式的自定义 Cookie 策略。·Request 的输出流可以避免流中内容直接缓冲到 Socket 服务器。·Response 的输入流可以有效的从 Socket 服务器直接读取相应内容。·在 HTTP 1.0 和 HTTP 1.1 中利用 KeepAlive 保持持久连接。·直接获取服务器发送的 response code 和 headers。·设置连接超时的能力。·实验性的支持 HTTP 1.1 response caching。·源代码基于 Apache License 可免费获取。 Apache HttpClient 使用流程使用 HttpClient 发送请求、接收响应很简单，一般需要如下几步即可。 ·创建 HttpClient 对象。·创建请求方法的实例，并指定请求 URL。如果需要发送 GET 请求，创建 HttpGet 对象；如果需要发送 POST 请求，创建 HttpPost 对象。·如果需要发送请求参数，可调用 HttpGet、HttpPost 共同的 setParams(HttpParams params) 方法来添加请求参数；对于 HttpPost 对象而言，也可调用 setEntity(HttpEntity entity) 方法来设置请求参数。·调用 HttpClient 对象的 execute(HttpUriRequest request) 发送请求，该方法返回一个 HttpResponse。·调用 HttpResponse 的 getAllHeaders()、getHeaders(String name) 等方法可获取服务器的响应头；调用 HttpResponse 的 getEntity() 方法可获取 HttpEntity 对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。·释放连接。无论执行方法是否成功，都必须释放连接 Apache HttpClient 使用实例pom.xml 配置1234567891011121314151617&lt;!-- Apache Http Begin --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;fluent-hc&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpmime&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Apache Http End --&gt; 主要增加了 org.apache.httpcomponents:httpclient、org.apache.httpcomponents:fluent-hc、org.apache.httpcomponents:httpmime 三个依赖 创建 HttpGet 请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.funtl.hello.httpclient;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;public class MyTest &#123; public static void main(String[] args) &#123; get(); &#125; private static void get() &#123; // 创建 HttpClient 客户端 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建 HttpGet 请求 HttpGet httpGet = new HttpGet(&quot;http://localhost:8080/content/page?draw=1&amp;start=0&amp;length=10&quot;); // 设置长连接 httpGet.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;); // 设置代理（模拟浏览器版本） httpGet.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;); // 设置 Cookie httpGet.setHeader(&quot;Cookie&quot;, &quot;UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4&quot;); CloseableHttpResponse httpResponse = null; try &#123; // 请求并获得响应结果 httpResponse = httpClient.execute(httpGet); HttpEntity httpEntity = httpResponse.getEntity(); // 输出请求结果 System.out.println(EntityUtils.toString(httpEntity)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 无论如何必须关闭连接 finally &#123; if (httpResponse != null) &#123; try &#123; httpResponse.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (httpClient != null) &#123; try &#123; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 创建 HttpPost 请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.funtl.hello.httpclient;import org.apache.http.HttpEntity;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.List;public class MyTest &#123; public static void main(String[] args) &#123; post(); &#125; private static void post() &#123; // 创建 HttpClient 客户端 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建 HttpPost 请求 HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/content/page&quot;); // 设置长连接 httpPost.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;); // 设置代理（模拟浏览器版本） httpPost.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;); // 设置 Cookie httpPost.setHeader(&quot;Cookie&quot;, &quot;UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4&quot;); // 创建 HttpPost 参数 List&lt;BasicNameValuePair&gt; params = new ArrayList&lt;BasicNameValuePair&gt;(); params.add(new BasicNameValuePair(&quot;draw&quot;, &quot;1&quot;)); params.add(new BasicNameValuePair(&quot;start&quot;, &quot;0&quot;)); params.add(new BasicNameValuePair(&quot;length&quot;, &quot;10&quot;)); CloseableHttpResponse httpResponse = null; try &#123; // 设置 HttpPost 参数 httpPost.setEntity(new UrlEncodedFormEntity(params, &quot;UTF-8&quot;)); httpResponse = httpClient.execute(httpPost); HttpEntity httpEntity = httpResponse.getEntity(); // 输出请求结果 System.out.println(EntityUtils.toString(httpEntity)); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 无论如何必须关闭连接 finally &#123; try &#123; if (httpResponse != null) &#123; httpResponse.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (httpClient != null) &#123; httpClient.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>HttpClient，API接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git版本控制系统]]></title>
    <url>%2F2019%2F03%2F12%2FGit%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[分布式的版本控制系统：git中央集中式版本控制系统：SVN Git工作流集中式工作流 功能分支工作流 GitFlow 工作流]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Git</tag>
        <tag>Git工作流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见查询算法和数据结构]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%B8%B8%E8%A7%81%E6%9F%A5%E8%AF%A2%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[在学习数据库索引之前虚了解这些查询算法，以帮助理解和学习数据库索引的具体原理和优化方法。索引的本质便是数据结构。 查询算法顺序查找最基本的查询算法当然是顺序查找（linear search），也就是对比每个元素的方法，不过这种算法在数据量很大时效率是极低的。数据结构：有序或无序队列复杂度：O(n) 123456789//顺序查找int sequenceSearch(int a[], int value, int n)&#123; int i; for(i=0; i&lt;n; i++) if(a[i]==value) return i; return -1;&#125; 二分查找比顺序查找更快的查询方法应该就是二分查找了，二分查找的原理是查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。数据结构：有序数组复杂度：O(logn) 1234567891011//二分查找int binarySearch(int[] a,int key,int low,int high)&#123; int mid = (low + high)/2; if(key == a[mid])&#123; return mid; &#125;else if(key &lt; a[mid])&#123; return binarySearch(a,key,low,mid-1); &#125;else&#123; return binarySearch(a,key,mid+1,high); &#125;&#125; 二叉排序树查找二叉排序树的特点是： 1、若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；2、若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；3、它的左、右子树也分别为二叉排序树。搜索的原理： 1、若b是空树，则搜索失败，否则：2、若x等于b的根节点的数据域之值，则查找成功；否则：3、若x小于b的根节点的数据域之值，则搜索左子树；否则：查找右子树。数据结构：二叉排序树时间复杂度： O(log2N) 哈希散列法(哈希表) 其原理是首先根据key值和哈希函数创建一个哈希表（散列表），燃耗根据键值，通过散列函数，定位数据元素位置。 数据结构：哈希表时间复杂度：几乎是O(1)，取决于产生冲突的多少。 分块查找 分块查找又称索引顺序查找，它是顺序查找的一种改进方法。其算法思想是将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，依次类推。 算法流程： 1、先选取各块中的最大关键字构成一个索引表；2、查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。 这种搜索算法每一次比较都使搜索范围缩小一半。它们的查询速度就有了很大的提升，复杂度为。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 B树]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法</tag>
        <tag>查询算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（五）]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第五部分 高效并发第13章 线程安全与锁优化线程安全Google搜索对线程安全的定义：如果一个对象可以安全地被多个线程同时使用，那它就是线程安全的。 《Java Concurrency In Practice(Java并发实战)》对线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象时线程安全的。 Java语言中的线程安全线程安全程度分类： 1、不可变不可变的线程一定是安全的，无论是对象的方法实现还是方法的调用者，都不需要再此采取任何安全保障措施。final修饰的基本类型变量都是不可变的。String类的对象也是不可变的。如果调用它的substring(),replace(),concat()等方法都不会影响它原来的值，只会返回一个新构造的字符串对象。常用的不可变对象还有枚举类型，java.lang.Number的部分类。还有包装类型，比如Integer类、Long类、Double类等。 2、绝对线程安全3、相对线程安全相对线程安全就是我们通常意义上的线程安全，它需要保证对这个对象单独的操作是安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。例如Vector类、HashTable类、Conllections的sychronizedCollection()方法包装的集合等。4、线程兼容线程兼容是指本身不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境下的安全地使用。我们通常说的线程是不安全的，绝大多数时候是指这个情况。5、线程对立线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。这种代码是很少见的，通常是有害的，应当避免。 线程安全的实现方法1、互斥同步(Mutual Exclusion &amp; Synchronization) 1&gt;sychronized关键字:最基本的互斥同步手段就是sybchronized关键字。synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的情况。synchronized同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。2&gt;ReentrantLock(重入锁):来自java.util.concurrent包。在基本用法上，ReentrantLock和synchronized关键字很相似，都具备一样的线程重入特征，只是在代码书写上有所不同。ReentrantLock加锁示例：1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.locks.ReentrantLock;public class ReentrantLockTest extends Thread &#123; public static ReentrantLock lock = new ReentrantLock(); public static int i = 0; public ReentrantLockTest(String name) &#123; super.setName(name); &#125; @Override public void run() &#123; for (int j = 0; j &lt; 10000000; j++) &#123; lock.lock(); try &#123; System.out.println(this.getName() + &quot; &quot; + i); i++; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; /** * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; ReentrantLockTest test1 = new ReentrantLockTest(&quot;thread1&quot;); ReentrantLockTest test2 = new ReentrantLockTest(&quot;thread2&quot;); test1.start(); test2.start(); test1.join(); test2.join(); System.out.println(i); &#125;&#125; 最重要的是ReentrankLock增加了一些高级功能：等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待。公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平锁，ReentrantLock默认情况下也是非公平的，要通过带boolean值的构造函数（ReentrantLock fairLock = new ReentrantLock(true)）。可限时：超时不能获得锁，就返回false，不会永久等待构成死锁。使用lock.tryLock(long timeout, TimeUnit unit)来实现可限时锁，参数为时间和单位。 如需使用以上功能，使用ReentrankLock最好，否则使用synchronized性能更好(jdk1.6以后，因为1.6以后版本对synchronized做了逐步优化)。 2、非阻塞同步(Non-Blocking Synchronization) 互斥同步属于悲观并发策略。总是认为不加锁肯定会出问题。悲观锁总是会将还未获得锁的线程挂起，也就是进入阻塞状态，所以互斥同步也叫阻塞同步。 随着硬件指令集的发展，我们有了另一个选择：基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程共享数据，就不加锁。这种乐观的并发策略不需要把线程挂起，所以这种同步叫非阻塞同步。 这个过程需要操作和冲突检测这两个步骤具备原子性，这里的原子性只能靠硬件来完成，就需要一些指令来完成这些操作。这类常用指令有：·试并设置(Test-and-Set)·取并增加(Fetch-and-Increment)·换(Swap)·较并交换(Compare-and-Swap,CAS)·载链接/条件储存(Load-Linked/Store-Conditional,LL/SC) 乐观锁CAS详细解释和使用点这里或参照书394页 3、无同步方案 可重入代码线程本地存储 锁优化Java虚拟机不断对锁进行改进优化。 自旋锁互斥同步中挂起和恢复线程会浪费很多性能，自旋锁就是让这些线程不用挂起，执行一个忙循环(自旋)，这便是自旋锁。 jdk1.4.2中引入自旋锁，但是默认关闭。jdk1.6默认打开。 锁消除锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。 锁粗化将对一个对象操作的零碎锁范围整合，只需要加一次锁就可以了 轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 偏向锁消除数据在无竞争情况下的同步原语。 这几项优化原理具体参照书398，此处只是简单介绍目的。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（四）]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第四部分 高效并发第12章 Java内存模型和线程TPS：衡量一个服务器性能好坏，每秒事物处理数(Transactions Per Second TPS)是重要指标之一，它代表这服务器每秒内能响应的请求总数，而TPS又与高效并发有密切关系。 高速缓存(Cache)：基于高速缓存的存储交互很好地解决了处理器和内存之间的速度矛盾。但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性。 Java内存模型(JMM)Java内存模型(Java Memory Model,JMM),Java虚拟机定义java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，从而实现在平台下达到一致的内存访问效果，实现java虚拟机的跨平台性。 主内存和工作内存Java内存模型主要是定义程序中各个变量的访问规则。 工作内存：每条线程还有自己的工作内存(Working Memory),线程中的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值)都必需在工作内存中进行，而不能直接读写主内存中的变量。 程序运行时主要访问读写的是工作内存。 内存间的交互操作·lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。·unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。·read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用值放入工作内存的变量副本中。·use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。·assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。·store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。·write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则： ·不允许read和load、store和write操作之一单独出现·不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。·不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。·一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。·一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现·如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值·如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。·对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。 对于volatile型变量的特殊规则volatile具有可见性、有序性，不具备原子性。禁止指令重排序。 重排序原子性、可见性和有序性原子性：指该操作是不可再分的。 基本数据类型是具备原子性的。 sychronized块之间的操作也具备原子性。 可见性：指当前一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 volatile关键字修饰的变量可以实现可见性。 sychronized块可以实现可见性。 final关键字修饰变量具备可见性。 有序性：即程序执行时按照代码书写的先后顺序执行。在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile关键字修饰变量禁止指令重排序，具备有序性。 sychronized块具备有序性。 先行发生原则(happens-before)它是判断数据是否存在竞争和线程是否安全的重要依据，依靠这个原则可以通过规则解决并发环境下两个操作之间是否存在冲突的所有问题。 Java内存模型中存在的天然的先行发生关系(如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意进行重排序)： ·程序次序规则：同一个线程内，按照代码出现的顺序，前面的代码先行于后面的代码，准确的说是控制流顺序，因为要考虑到分支和循环结构。·管程锁定规则：一个unlock操作先行发生于后面（时间上）对同一个锁的lock操作。·volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作。·线程启动规则：Thread的start( )方法先行发生于这个线程的每一个操作。·线程终止规则：线程的所有操作都先行于此线程的终止检测。可以通过Thread.join( )方法结束、Thread.isAlive( )的返回值等手段检测线程的终止。·线程中断规则：对线程interrupt( )方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt( )方法检测线程是否中断·对象终结规则：一个对象的初始化完成先行于发生它的finalize（）方法的开始。·传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C。 时间上的先后顺序对先行发生没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的影响，一切以先行发生原则为准。 Java与线程Java线程状态①初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。②运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的成为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得cpu 时间片后变为运行中状态（running）。③阻塞(BLOCKED)：表线程阻塞于锁。④等待(WAITING)：也叫无限期等待。进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。以下方式会让线程进入无限期等待状态：·没有设置Timeout参数的Object.wait()方法。·没有设置Timeout参数的Thread.join()方法。·LockSupport.park()。⑤超时等待(TIME_WAITING)：也叫限期等待。该状态不同于WAITING，它可以在指定的时间内自行返回。以下方式会让线程进入限期等待状态：·Thread.sleep()方法。·设置了Timeout参数的Object.wait()方法。·设置了Timeout参数的Thread.join()方法。·LockSupport.parkNanos()方法。·LockSupport.parkUntil()方法。 ⑥终止(TERMINATED)：表示该线程已经执行完毕]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2F2019%2F03%2F06%2F%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>加密内容</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库练习]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Student(Sid,Sname,Sage,Ssex)学生表Sid：学号Sname：学生姓名Sage：学生年龄Ssex：学生性别Course(Cid,Cname,T#)课程表Cid：课程编号Cname：课程名称Tid：教师编号SC(Sid,Cid,score)成绩表Sid：学号Cid：课程编号score：成绩Teacher(Tid,Tname)教师表Tid：教师编号：Tname：教师名字 问题：1、查询“001”课程比“002”课程成绩高的所有学生的学号1234select a.sid from (select sid,score from sc where cid=&apos;001&apos;)a,(select sid,score from sc where cid=&apos;002&apos;)b where a.sid = b.sid and a.score&gt;b.score; 2、查询平均成绩大于60分的同学的学号和平均成绩123select sid,avg(score) from scgroup by sid having avg(score)&gt;60; 3、查询所有同学的学号、姓名、选课数、总成绩1234567select s.sid,s.sname,count_cid as 选课数, sum_score as 总成绩from student sleft join (select sid,count(cid) as count_cid,sum(score) as sum_score from sc group by sid )scon s.sid = sc.sid; 4、查询姓‘李’的老师的个数：123select count(tname)from teacher where tname like &apos;李%&apos;; 5、查询没有学过“叶平”老师可的同学的学号、姓名：1234567891011select s.sid,s.sname from student as s where s.sid not in ( select DISTINCT sid from sc as sc where sc.cid in ( select cid from course as c left join teacher as t on c.tid = t.tid where t.tname = &apos;叶平&apos;)); 6、查询学过“叶平”老师所教的所有课的同学的学号、姓名：12345678910111213141516select s.sid,s.sname from student as s where s.sid in ( select distinct sc.sid from sc as sc where sc.cid in ( select cid from course as c left join teacher as t on c.tid = t.tid where t.tname = &apos;叶平&apos;) group by sc.sid HAVING count(cid)= (select count(cid) from course as c left join teacher as t on c.tid = t.tid where t.tname = &apos;叶平&apos;)); 7、查询学过“011”并且也学过编号“002”课程的同学的学号、姓名：123456789101112131415161718SELECT s.sid,s.sname from student as s left join sc as sc on s.sid = sc.sidwhere sc.cid = &apos;001&apos;and EXISTS( select * from sc as sc_2 where sc.sid = sc_2.sid and sc_2.cid=&apos;002&apos;);select s.sid,s.snamefrom student as s left join sc as sc on sc.sid = s.sidwhere sc.cid = &apos;001&apos;and s.sid in ( select sid from sc as sc_2 where sc_2.cid=&apos;002&apos; and sc_2.sid = sc.sid); 8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名：12345678select sid,snamefrom (select student.sid,student.sname,score, (select score from sc as sc_2 where sc_2.sid = student.sid and sc_2.cid = &apos;002&apos;) as score2 from student,sc where student.sid=sc.sid and cid = &apos;001&apos;) s_2where score2&lt;score; 9、查询所有课程成绩小于60的同学的学号、姓名：123456789101112select sid,snamefrom studentwhere sid not in (select s.sid from student s,sc where s.sid=sc.sid and score&gt;60 );select sid,snamefrom student swhere not EXISTS (select s.sid from sc where sc.sid = s.sid and sc.score&gt;60); 10、查询没有学全所有课的同学的学号、姓名：1234567891011121314select s.sid,s.snamefrom student s ,sc sc where s.sid = sc.sidgroup by s.sid,s.snamehaving count(sc.cid)&lt;(select count(cid) from course);select s.sid,s.snamefrom student s right join sc sc on s.sid = sc.sidgroup by s.sid,s.snamehaving count(sc.cid)&lt;(select count(cid) from course); 11、查询至少有一门课与学号为“1001”同学所学相同的同学的学号和姓名：123456789101112131415161718select student.sid,snamefrom student,sc where student.sid = sc.sidand cid in (select cid from sc where sid=&apos;1001&apos;);select s.sid,s.snamefrom sc sc left join student as son sc.sid = s.sidwhere sc.cid in (select cid from sc where sid=&apos;1001&apos;);select sc_1.sid,s.snamefrom sc sc_1 left join student as son sc_1.sid = s.sidwhere exists (select sc_2.cid from sc as sc_2 where sc_1.cid = sc_2.cid and sc_2.sid = &apos;1001&apos;); 12、查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名；13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩：1234567update sc set score = (select avg(sc_2.score) from sc sc_2 where sc_2.cid = sc.cid)where cid in (select c.cid from course c left join teacher t on t.tid = c.tid where t.tname = &apos;叶平&apos;); 14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名：12345678910111213141516select sc_1.sid from (select cid from sc where sid=&apos;1002&apos;)aleft join sc sc_1 on a.cid = sc_1.cidwhere sc_1.sid&lt;&gt;&apos;1002&apos; group by sc_1.sid having count(sc_1.cid) = (select count(cid) from sc where sid=&apos;1002&apos;);select a.sid,s.sname from (select sid,GROUP_CONCAT(cid order by cid separator &apos;,&apos;) as cid_str from sc where sid=&apos;1002&apos;)b,(select sid,GROUP_CONCAT(cid order by cid separator &apos;,&apos;) as cid_str from sc group by sid)aleft join student s on a.sid = s.sidwhere a.cid_str = b.cid_str and a.sid&lt;&gt;&apos;1002&apos;; 15、删除学习“叶平”老师课的SC表记录：12345delete from sc WHEREcid in (select c.cid from course c LEFT JOIN teacher t on c.tid=t.tid where t.tname = &apos;叶平&apos;); 16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、002号课的平均成绩：1234insert into sc select sid,&apos;002&apos;,(select avg(score) from sc where cid=&apos;0022&apos;)from student where sid not in (select sid from sc where cid=&apos;002&apos;); 17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示：学生ID，数据库，企业管理，英语，有效课程数，有效平均分：1234567891011select sid as 学生id,(SELECT score from sc where sc.sid = t.sid and cid=&apos;004&apos;) as 数据库,(select score from sc where sc.sid = t.sid and cid=&apos;001&apos;) as 企业管理,(select score from sc where sc.sid = t.sid and cid=&apos;015&apos;) as 英语,count(cid) as 有效课程数, avg(t.score) as 平均成绩from sc as t group by sidorder by avg(t.score); 18、查询各科成绩最高和最低的分：以如下的形式显示：课程ID，最高分，最低分123456789101112131415select l.cid as 课程id,l.score as 最高分,r.score as 最低分from sc l,sc rwhere l.cid = r.cidand l.score = (select max(t.score) from sc t where l.cid = t.cid group by t.cid)and r.score = (select min(t.score) from sc t where r.cid = t.cid group by t.cid)order by l.cid;select cid as 课程id,max(score) as 最高分,min(score) as 最低分from sc group by cid; 19、按各科平均成绩从低到高和及格率的百分数从高到低顺序：12345678910111213SELECT t.cid as 课程号,c.cname as 课程名,COALESCE(avg(score),0) as 平均成绩,100*sum(case when COALESCE(score,0)&gt;=60 then 1 else 0 END)/count(*) as 及格百分数from sc tleft join course c on t.cid = c.cidgroup by t.cidorder by 100*sum(case when COALESCE(score,0)&gt;=60 then 1 else 0 END)/count(*); 20、查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）：21、查询不同老师所教不同课程平均分从高到低显示：123456789select t.tid as 教师id,t.tname as 教师姓名,sc.cid as 课程id,avg(score) as 平均成绩from sc as scLEFT JOIN course c on sc.cid = c.cidleft join teacher t on c.tid = t.tidgroup by sc.cid order by avg(sc.score) desc; 22、查询如下课程成绩第3名到第6名的学生成绩单：企业管理(001)，马克思(002)，UML(003)，数据库(004)：23、统计下列各科成绩，各分数段人数：课程ID，课程名称，[100-85],[85-70],[70-60],[ 小于60] ：123456789select sc.cid as 课程id,cname as 课程名称,sum(case when score between 85 and 100 then 1 else 0 end) as &apos;[100-85]&apos;,sum(case when score between 70 and 85 then 1 else 0 end) as &apos;[85-70]&apos;,sum(case when score between 60 and 70 then 1 else 0 end) as &apos;[70-60]&apos;,sum(case when score&lt;60 then 1 else 0 end) as &apos;[60-0]&apos;from sc as sc left join course as con sc.cid = c.cidgroup by sc.cid; 24、查询学生平均成绩及其名次：1234567select 1+(select count(distinct 平均成绩) from (select sid,avg(score) as 平均成绩 from sc group by sid)t1 where 平均成绩&gt;t2.平均成绩) as 名次,sid as 学生学号,平均成绩 from (select sid,avg(score) 平均成绩 from sc group by sid) as t2order by 平均成绩 desc; 25、查询各科成绩前三名的记录（不考虑成绩并列情况）：12345678select sid,cid,scorefrom sc sc_1where (select count(3) from sc sc_2 where sc_1.cid = sc_2.cid and sc_2.score&gt;=sc_1.score)&lt;=2 order by sc_1.cid); 26、查询每门课程被选修的学生数：123select cid, count(sid)from sc group by cid; 27、查询出只选修一门课程的全部学生的学号和姓名：1234567select sc.sid,s.sname,count(sc.cid) as 课程数from sc as scLEFT JOIN student as son sc.sid = s.sidgroup by sc.sidhaving count(sc.cid)=1; 28、查询男生、女生人数：123456select count(ssex) as 男生人数from studentgroup by ssexhaving ssex = &apos;男&apos;;select count(2) from studentwhere ssex = &apos;女&apos;; 29、查询姓“张”的学生名单：123select sid,snamefrom student where sname like &apos;张%&apos;; 30、查询同名同姓的学生名单，并统计同名人数：1234select sname,count(8)from student group by snamehaving count(8)&gt;1; 31、1981年出生的学生名单（注：student表中sage列的类型是datetime）:32、查询平均成绩大于85的所有学生的学号、姓名和平均成绩：123456select s.sname,sc.sid,avg(sc.score) as 平均成绩from sc as scleft join student as s on sc.sid = s.sidgroup by sc.sid having avg(sc.score)&gt;85; 33、查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列：1234select cid,avg(score)from sc group by cidorder by avg(score),cid desc; 34、查询课程名称为“数据库”，且分数低于60的学生名字和分数：12345select c.cname,s.sid,s.sname,sc.scorefrom course cleft join sc on sc.cid = c.cidLEFT JOIN student s on s.sid = sc.sidwhere c.cname = &apos;数据库&apos; and sc.score&lt;60; 35、查询所有学生的选课情况：1234select sc.sid,sc.cid,s.sname,c.cnamefrom sc LEFT JOIN course c on sc.cid = c.cidleft join student s on sc.sid = s.sid; 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数：12345select distinct s.sid,s.sname,sc.cid,sc.scorefrom sc left join student s on sc.sid = s.sidleft join course c on sc.cid = c.cidwhere sc.score&gt;70; 37、查询不及格的课程，并按课程号从大到小的排列：1234select cidfrom sc where score&lt;60ORDER BY cid; 38、查询课程编号为“003”且课程成绩在80分以上的学生的学号和姓名：1234select sc.sid,s.sname from sc left join student s on sc.sid = s.sidwhere sc.cid = &apos;003&apos; and sc.score&gt;80; 39、求选了课程的学生人数：12select count(2) from (select distinct sid from sc)a; 40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩：12345678910select s.sname,sc.scorefrom sc sc left join student s on sc.sid = s.sidleft join course c on sc.cid = c.cidleft join teacher t on c.tid = t.tidwhere t.tname = &apos;叶平&apos;and sc.score = (select max(score) from sc sc_1 where sc.cid = sc_1.cid); 41、查询各个课程及相应的选修人数：1select cid,count(*) from sc group by cid; 42、查询不同课程成绩相同的学生和学号、课程号、学生成绩：1234select DISTINCT a.sid,a.cid,a.scorefrom sc as a ,sc as b where a.score = b.scoreand a.cid &lt;&gt; b.cid; 43、查询每门课程成绩最好的前两名：44、统计每门课程的学生选修人数(超过10人的课程才统计)。要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序：12345select cid as 课程号,count(8) as 选修人数from scgroup by cidHAVING count(sid)&gt;10order by count(8) desc,cid; 45、检索至少选修两门课程的学生学号：1234select sidfrom scgroup by sidhaving count(8)&gt;=2; 46、查询全部学生选修的课程和课程号和课程名：123select cid,cnamefrom course where cid in (select cid from sc group by cid); 47、查询没学过”叶平”老师讲授的任一门课程的学生姓名：12345678select sname from student where sid not in ( select sid from sc,course,teacher where course.tid = teacher.tid and sc.cid = course.cid and teacher.tname=&apos;叶平&apos;); 48、查询两门以上不及格课程的同学的学号以及其平均成绩：12345678910select sid,avg(COALESCE(score,0))from scwhere sid in ( select sid from sc where score&lt;60 group by sid having count(8)&gt;2)group by sid; 49、检索“004”课程分数小于60，按分数降序排列的同学学号：12345select sid,scorefrom scwhere cid=&apos;004&apos;and score&lt;60order by score desc; 50、删除“002”同学的“001”课程的成绩：123delete from scwhere sid = &apos;002&apos;and cid = &apos;001&apos;;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC工作原理]]></title>
    <url>%2F2019%2F03%2F04%2FSpringMVC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络经典面试题—从输入URL到页面加载发生了什么]]></title>
    <url>%2F2019%2F03%2F04%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[1、DNS域名解析2、TCP连接3、HTTP请求4、服务器处理请求返回报文5、浏览器渲染页面 DNS域名解析域名(url)解析成IP地址的过程 递归查询方法 根域名服务器——&gt;顶级域名服务器——&gt;网站服务器——&gt;IP地址例：www.chi365.cn . ——&gt; .cn ——&gt;chi365.cn——&gt;IP地址 TCP连接三次握手 建立tcp连接 四次挥手 断开连接 HTTP请求建立稳定传输连接以后就可以构建并发送HTTP请求报文。 HTTP请求报文格式：请求行+请求头+空行+消息体，请求行包括请求方式（GET/POST/DELETE/PUT）、请求资源路径（URL）、HTTP版本号； HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。 状态码：1** 这一类型的状态码，代表请求已被接受，需要继续处理。2** 成功，这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。3** 这类状态码代表需要客户端采取进一步的操作才能完成请求。重定向4** 请求错误，这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。5** 服务器错误，这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。 获得HTTP请求报文，解析封装成HTTP request对象（这部分一般由Web服务器完成，如tomcat）。 浏览器渲染页面]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机网络</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序12345678910111213141516/* 外层循环n-1，内层循环n-1-i，比较j和j+1。*/public int[] mpSort(int[] a)&#123; int n = a.length; for(int i=0;i&lt;n-1;i++)&#123; for(int j=0;j&lt;n-1-i;j++)&#123; if(a[j]&gt;a[j+1])&#123; int temp = a[j+1]; a[j+1] = a[j]; a[j] = temp; &#125; &#125; &#125; return a;&#125; 选择排序123456789101112131415public int[] selectSort(int[] a)&#123; int n = a.length; for(int i=0;i&lt;n;i++)&#123; int max = 0; for(int j=0;j&lt;n-i;j++)&#123; if(a[j]&gt;a[max])&#123; max = j; &#125; &#125; int temp = a[n-1-i]; a[n-1-i] = a[max]; a[max] = temp; &#125; return a;&#125; 插入排序123456789101112131415public int[] insertSort(int[] a)&#123; int i,j,temp; for(i=1;i&lt;a.length;i++)&#123; temp = a[i]; for(j = i-1;j&gt;=0;j--)&#123; if(temp&gt;=a[j])&#123; break;//找到插入位置退出循环 &#125;else&#123; a[j+1] = a[j];//未到插入位置往后移 &#125; &#125; a[j+1] = temp;//插入位置赋值 &#125; return a;&#125; 快速排序12345678910111213141516171819202122232425262728293031public void quickSort(int[] a,int low,int high)&#123; if(low&gt;high)&#123; return; &#125; int start = low;//左部循环指针，初始指向最左端 int end = high;//右部循环指针，初始指向最右端 int key = a[low];//选一个key while (start&lt;end)&#123; //右部循环，如果end元素大于key，指针向左移，如果end元素小于key，退出循环 while (start&lt;end &amp;&amp; a[end]&gt;key)&#123; end--; &#125; //左部循环，如果start元素小于key，指针向右移，如果start元素大于key，退出循环 while(start&lt;end &amp;&amp; a[start]&lt;=key)&#123; start++; &#125; //交换两指针对应元素，继续循环，直到两指针指向同一元素。目的是将所以大于key的元素移向右端，所有小于key的元素移向左端。 if(start&lt;end)&#123; int temp = a[start]; a[start] = a[end]; a[end] = temp; &#125; &#125; //将key元素与指针所指元素互换，形成key左部全部小于key，右部全部大于key a[low] = a[start]; a[start] = key; //分别递归调用两端元素 quickSort(a,low,start-1); quickSort(a,start+1,high);&#125; 【一个非常全面的排序算法详解】——&gt;在这里]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——传输层协议]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94TCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[网络七层协议 TCP协议和UDP协议TCP协议特点1、面向连接的运输层协议。2、每条TCP连接只能有两个端点，是点对点的连接。3、TCP服务提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达。4、面向字节流。 UDP协议特点1、UDP是无连接的传输层协议。2、不可靠。3、面向报文的。对应用层交下来的报文，不合并、不拆分，保留报文边界。4、UDP没有拥塞处理。5、UDP支持一对一、一对多、多对多。 TCP协议和UDP协议区别1、TCP是可靠传输,UDP是不可靠传输; 2、TCP面向连接,UDP无连接; 3、TCP传输数据有序,UDP不保证数据的有序性; 4、TCP不保存数据边界,UDP保留数据边界; 5、TCP传输速度相对UDP较慢; 6、TCP有流量控制和拥塞控制,UDP没有; 7、TCP是重量级协议,UDP是轻量级协议; 8、TCP首部较长２０字节,UDP首部较短８字节; 基于TCP和UDP的常用协议HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议 TCP协议三次握手和四次挥手第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 常见面试题【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 【问题3】为什么不能用两次握手进行连接？ 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75s发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机网络</tag>
        <tag>TCP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（三）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略垃圾回收算法标记清除算法首先标记要回收的对象，标记完成后统一回收被标记的对象。缺点：1.效率低。2.会产生大量不连续的内存碎片。 复制算法它将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 缺点很明显，内存空间比原来少了一半。 JAVA虚拟机就是用这张算法回收新生代。将内存分为Eden和两个Survivor区，每次使用Eden和一个Survivor区，当回收时，将Eden和Survivor区还存活的对象一次性全复制到另一个Survivor区，最后清除Eden和这个Survivor区的内存。HotSpot虚拟机默认Eden和Survivor大小比例是8:1，所以每次使用90%内存。当Survivor区不够用时，需要依赖其他内存（老年代）进行分配担保。 标记-整理算法老年代一般不能直接选用复制算法，因为有大量存活对象需要复制。根据老年代的特点，有人提出标记整理算法，标记过程和标记清除算法一样，但后面是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代回收算法Java虚拟机将堆内存分为新生代和老生代，新生代使用复制算法；老生代使用标记清除或者标记整理算法。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（二）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略判断对象需要回收的算法引用计数法给对象添加一个引用技术器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象都是不能被再次使用的。 Java虚拟机没有选用引用计数算法来管理内存的，原因是它很难解决相互循环引用的问题。 1234例如：objA.instance = objB;objB.instance = objA;由于这两个对象相互引用着所以计数器永远不为0. 可达性分析算法主流语言多是用可达性分析算法判断对象是否存活的。这个算法的基本思路是：通过一系列的GC Roots的对象为起始点，从这些节点开始向下搜索，搜索走过的路径为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 JDK关于“引用”的定义JDK1.2以后，Java对引用的概念进行补充，引用分为： 强引用（Strong Reference）：垃圾回收器永远不会回收。 软引用（Soft Reference）：在系统要发生内存溢出之前回收。若回收后还是没有足够内存，才会报出内存溢出异常OOM。 弱引用（Weak Reference）：比软引用还要弱。无论当前内存是否够用，垃圾回收器都会在下次垃圾回收之前就回收。 虚引用（Phantom Reference）：最弱。 即使在可达性分析算法不可达的对象，也并不是立刻就回收。 可达性算法不可达–&gt;后存放在F-Queue队列–&gt;finalize()方法 执行finalize()方法的对象依然有可能存活。 回收方法区方法区也叫“永久代”，永久代的回收主要回收两部分：废弃常量和无用的类。 无用的类：该类所有实例已经被回收；加载该类的ClassLoader已经被回收；无法在任何地方通过反射访问该类的方法。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（一）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第二章 JVM内存管理机制程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每条线程都有一个独立的程序计数器，所以程序计数器是线程私有的内存。此内存区是唯一一个在java虚拟机中没有规定任何OutOfMemoryError情况的区域。 JAVA虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法接口等信息。虚拟机栈也是线程私有的。Java虚拟机栈可以动态拓展，也可以固定长度，如果无法申请到足够的内存，就会抛出OutOfMemoryError。如果线程请求的线程深度大于虚拟机所允许的深度则会抛出StackOverflowError（递归调用易出现）。 局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，指向对象的指针）和returnAddress类型（指向一条字节码指令的地址）。局部变量空间单位（Slot），64位长的long和double占用两个Slot，其余占用1个Slot。 本地方法栈服务于Native方法。与虚拟机栈相似。 Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是线程共享的。在虚拟机启动时创建。存放对象实例，几乎所有对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，所以也叫GC堆。垃圾回收机制大多采用分代收集算法，所以Java堆还可以细分为新生代、老生代，再细致分为Eden区、From Survivor区、To Survivor区等。Java堆也是可扩展的，无法扩展时抛出OutOfMemoryError。 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是线程共享的内存区域。 运行时常量池是方法区的一部分，用于存放编译期生成的变量（类加载后进入方法区的变量）]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客编写]]></title>
    <url>%2F2019%2F02%2F28%2F111%2F</url>
    <content type="text"><![CDATA[评论插件：valine（数据库LeanCloud，账号163邮箱） 分类添加：在文章头部指定一个categories属性。 标签添加：在文章头部指定一个tags属性。 Markdown语法参考 代码示例：123public class hello&#123; &#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
