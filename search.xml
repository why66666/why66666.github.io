<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序12345678910111213141516/* 外层循环n-1，内层循环n-1-i，比较j和j+1。*/public int[] mpSort(int[] a)&#123; int n = a.length; for(int i=0;i&lt;n-1;i++)&#123; for(int j=0;j&lt;n-1-i;j++)&#123; if(a[j]&gt;a[j+1])&#123; int temp = a[j+1]; a[j+1] = a[j]; a[j] = temp; &#125; &#125; &#125; return a;&#125; 选择排序123456789101112131415public int[] selectSort(int[] a)&#123; int n = a.length; for(int i=0;i&lt;n;i++)&#123; int max = 0; for(int j=0;j&lt;n-i;j++)&#123; if(a[j]&gt;a[max])&#123; max = j; &#125; &#125; int temp = a[n-1-i]; a[n-1-i] = a[max]; a[max] = temp; &#125; return a;&#125; 插入排序123456789101112131415public int[] insertSort(int[] a)&#123; int i,j,temp; for(i=1;i&lt;a.length;i++)&#123; temp = a[i]; for(j = i-1;j&gt;=0;j--)&#123; if(temp&gt;=a[j])&#123; break;//找到插入位置退出循环 &#125;else&#123; a[j+1] = a[j];//未到插入位置往后移 &#125; &#125; a[j+1] = temp;//插入位置赋值 &#125; return a;&#125; 快速排序12345678910111213141516171819202122232425262728293031public void quickSort(int[] a,int low,int high)&#123; if(low&gt;high)&#123; return; &#125; int start = low;//左部循环指针，初始指向最左端 int end = high;//右部循环指针，初始指向最右端 int key = a[low];//选一个key while (start&lt;end)&#123; //右部循环，如果end元素大于key，指针向左移，如果end元素小于key，退出循环 while (start&lt;end &amp;&amp; a[end]&gt;key)&#123; end--; &#125; //左部循环，如果start元素小于key，指针向右移，如果start元素大于key，退出循环 while(start&lt;end &amp;&amp; a[start]&lt;=key)&#123; start++; &#125; //交换两指针对应元素，继续循环，直到两指针指向同一元素。目的是将所以大于key的元素移向右端，所有小于key的元素移向左端。 if(start&lt;end)&#123; int temp = a[start]; a[start] = a[end]; a[end] = temp; &#125; &#125; //将key元素与指针所指元素互换，形成key左部全部小于key，右部全部大于key a[low] = a[start]; a[start] = key; //分别递归调用两端元素 quickSort(a,low,start-1); quickSort(a,start+1,high);&#125; 【一个非常全面的排序算法详解】——&gt;在这里]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——传输层协议]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94TCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[网络七层协议 TCP协议和UDP协议TCP协议特点1、面向连接的运输层协议。2、每条TCP连接只能有两个端点，是点对点的连接。3、TCP服务提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达。4、面向字节流。 UDP协议特点1、UDP是无连接的传输层协议。2、不可靠。3、面向报文的。对应用层交下来的报文，不合并、不拆分，保留报文边界。4、UDP没有拥塞处理。5、UDP支持一对一、一对多、多对多。 TCP协议和UDP协议区别1、TCP是可靠传输,UDP是不可靠传输; 2、TCP面向连接,UDP无连接; 3、TCP传输数据有序,UDP不保证数据的有序性; 4、TCP不保存数据边界,UDP保留数据边界; 5、TCP传输速度相对UDP较慢; 6、TCP有流量控制和拥塞控制,UDP没有; 7、TCP是重量级协议,UDP是轻量级协议; 8、TCP首部较长２０字节,UDP首部较短８字节; 基于TCP和UDP的常用协议HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议 TCP协议三次握手和四次挥手第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 常见面试题【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 【问题3】为什么不能用两次握手进行连接？ 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75s发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（三）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略垃圾回收算法标记清除算法首先标记要回收的对象，标记完成后统一回收被标记的对象。缺点：1.效率低。2.会产生大量不连续的内存碎片。 复制算法它将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 缺点很明显，内存空间比原来少了一半。 JAVA虚拟机就是用这张算法回收新生代。将内存分为Eden和两个Survivor区，每次使用Eden和一个Survivor区，当回收时，将Eden和Survivor区还存活的对象一次性全复制到另一个Survivor区，最后清除Eden和这个Survivor区的内存。HotSpot虚拟机默认Eden和Survivor大小比例是8:1，所以每次使用90%内存。当Survivor区不够用时，需要依赖其他内存（老年代）进行分配担保。 标记-整理算法老年代一般不能直接选用复制算法，因为有大量存活对象需要复制。根据老年代的特点，有人提出标记整理算法，标记过程和标记清除算法一样，但后面是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代回收算法Java虚拟机将堆内存分为新生代和老生代，新生代使用复制算法；老生代使用标记清除或者标记整理算法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（二）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略判断对象需要回收的算法引用计数法给对象添加一个引用技术器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象都是不能被再次使用的。 Java虚拟机没有选用引用计数算法来管理内存的，原因是它很难解决相互循环引用的问题。 1234例如：objA.instance = objB;objB.instance = objA;由于这两个对象相互引用着所以计数器永远不为0. 可达性分析算法主流语言多是用可达性分析算法判断对象是否存活的。这个算法的基本思路是：通过一系列的GC Roots的对象为起始点，从这些节点开始向下搜索，搜索走过的路径为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 JDK关于“引用”的定义JDK1.2以后，Java对引用的概念进行补充，引用分为： 强引用（Strong Reference）：垃圾回收器永远不会回收。 软引用（Soft Reference）：描述一些还有用但是并非必需的对象。 弱引用（Weak Reference）：也是描述非必需对象。比软引用更弱。 虚引用（Phantom Reference）：最弱。 即使在可达性分析算法不可达的对象，也并不是立刻就回收。 可达性算法不可达–&gt;后存放在F-Queue队列–&gt;finalize()方法 执行finalize()方法的对象依然有可能存活。 回收方法区方法区也叫“永久代”，永久代的回收主要回收两部分：废弃常量和无用的类。 无用的类：该类所有实例已经被回收；加载该类的ClassLoader已经被回收；无法在任何地方通过反射访问该类的方法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解JAVA虚拟机学习笔记（一）]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第二章 JVM内存管理机制程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每条线程都有一个独立的程序计数器，所以程序计数器是线程私有的内存。此内存区是唯一一个在java虚拟机中没有规定任何OutOfMemoryError情况的区域。 JAVA虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法接口等信息。虚拟机栈也是线程私有的。Java虚拟机栈可以动态拓展，也可以固定长度，如果无法申请到足够的内存，就会抛出OutOfMemoryError。如果线程请求的线程深度大于虚拟机所允许的深度则会抛出StackOverflowError（递归调用易出现）。 局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，指向对象的指针）和returnAddress类型（指向一条字节码指令的地址）。局部变量空间单位（Slot），64位长的long和double占用两个Slot，其余占用1个Slot。 本地方法栈服务于Native方法。与虚拟机栈相似。 Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是线程共享的。在虚拟机启动时创建。存放对象实例，几乎所有对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，所以也叫GC堆。垃圾回收机制大多采用分代收集算法，所以Java堆还可以细分为新生代、老生代，再细致分为Eden区、From Survivor区、To Survivor区等。Java堆也是可扩展的，无法扩展时抛出OutOfMemoryError。 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是线程共享的内存区域。 运行时常量池是方法区的一部分，用于存放编译期生成的变量（类加载后进入方法区的变量）]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客编写]]></title>
    <url>%2F2019%2F02%2F28%2F111%2F</url>
    <content type="text"><![CDATA[评论插件：valine（数据库LeanCloud，账号163邮箱） 分类添加：在文章头部指定一个categories属性。 标签添加：在文章头部指定一个tags属性。 Markdown语法参考 代码示例：123public class hello&#123; &#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
